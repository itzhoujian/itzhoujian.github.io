<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[网站或APP点击流日志数据挖掘系统]]></title>
      <url>%2F2016%2F12%2F23%2F%E7%BD%91%E7%AB%99%E6%88%96APP%E7%82%B9%E5%87%BB%E6%B5%81%E6%97%A5%E5%BF%97%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%B3%BB%E7%BB%9F%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[zookeeper]]></title>
      <url>%2F2016%2F12%2F22%2Fzookeeper%2F</url>
      <content type="text"><![CDATA[是什么分布式协调服务框架，那么怎么理解分布式，其实就是一个完整的应用或功能或业务被分成若干个独立的部分或子业务，部署在不同的服务器上，所有部分去共同完成一个功能。优点：负载由单个节点转移到多个，提高效率缓解压力 避免了单个节点失效，整个系统崩溃的危险 提高利用率，子业务可以被反复使用而协调服务说白了就是为其它应用程序服务的。zookeeper本身也是分布式的(半数以上节点存活就能提供服务) 功能总的来说有2个管理用户提交的数据(存储或读取)为数据提供监听服务 集群角色分配原理(选举)以3台zookeepr为例，当启动第一个服务启动时发现配置文件中由3个server就会通过paxos算法进行投票，发现集群中没有leader，并且只有自己一个节点，就会投票给自己。当第二个服务启动后也发现集群中没有leader但是有一个folwer就会投给自己和第一个服务各一票，第一个服务也发现新节点也会重新投票，投给自己和对方一票，这时票数时2:2由于节点数已经过半所以paxos根据2个节点的myid号大小，将大的变为leader，其他节点在启动就会以这个leader为主，leader在维护各个folwer中的数据(这里由些偏差，待更新……) java客户端操作及监听器原理 public class SimpleZkClient { private static final String CONNECTSTRING = “192.168.25.61:2181,192.168.25.62:2181,192.168.25.63:2181”; private static final int SESSIONTIMEOUT = 200000; ZooKeeper zkClient = null; @Before public void init() throws IOException { // 初始化 Watcher监听节点的变化 此监听可以被后面的使用 zkClient = new ZooKeeper(CONNECTSTRING, SESSIONTIMEOUT, new Watcher() { @Override public void process(WatchedEvent event) { System.out.println(event.getType() + &quot;---------- &quot; + event.getPath()); try { // 因为只会监听一次，实际业务场景要时时监听 zkClient.getChildren(&quot;/&quot;, true); } catch (Exception e) { e.printStackTrace(); } } }); } // 创建节点到zk中 @Test public void testCreate() throws KeeperException, InterruptedException { // 1.znode路径及名称 2。节点的内容 3。安全策略 4。创建节点的模式（有4种 瞬时（带序号） 持久） zkClient.create(&quot;/uuuu&quot;, &quot;test&quot;.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL); } // 判断zode是否存在 返回许多元数据stat @Test public void testExit() throws KeeperException, InterruptedException { Stat stat = zkClient.exists(&quot;/&quot;, false); System.out.println(stat == null ? &quot;not exists&quot; : &quot;exists&quot;); } // 获取zk中的子节点 @Test public void testGet() throws KeeperException, InterruptedException { // true 表示给&quot;/&quot;节点加监听事件 用上一个监听 List&lt;String&gt; list = zkClient.getChildren(&quot;/&quot;, true); for (String string : list) { System.out.println(string); } Thread.sleep(Long.MAX_VALUE); } // 获取zode的数据 @Test public void getData() throws KeeperException, InterruptedException{ //1.znode的路径名 2.是否监听 3.获取版本 默认最新的 byte[] data = zkClient.getData(&quot;/uuuu&quot;, false, null); System.out.println(new String(data)); } //删除znode @Test public void deleteZnode() throws InterruptedException, KeeperException{ //参数-1，表示删除所有版本 zkClient.delete(&quot;/uuuu&quot;, -1); } //修改znode @Test public void setData() throws KeeperException, InterruptedException{ zkClient.setData(&quot;/test&quot;, &quot;i miss tangwei&quot;.getBytes(), -1); } } 其实所谓的监听就是服务端和客户端的通信(底层socket协议或rpc协议 )，zkClient有个连接zkServer的线程，当调用某个方法操作znode的时候如:调用getClildren()时会想zk集群中传递客户端的ip、port、path（监听的路径），zk会保存这些信息，当监听的路径发生改变时zk集群会根据以上信息找到zkClient的listern线程，listern线程调用process方法触发事件反馈给客户端处理。 应用场景主从协调(HA功能)、统一配置管理、统一名称服务(dubbo服务注册)、服务节点动态上下线、分布式共享锁 分布式应用服务器上下线动态感知程序开发需求：客户端实时洞察到服务器的变化(宕机、添加)解决思路：首先，服务器启动时就要向zk中注册Ephemeral node 信息(包括服务器地址，节点名，序列号……),然后，客户端启动时就要去getChildren获取当前在线服务器列表，并注册监听。当服务器某个节点挂掉之后临时znode会被删除，zk就会通知客户端的监听线程，客户端监听到上下znode变化事件就会调用process方法，在方法中重新获取在线服务器列表在监听。 分布式共享锁程序开发在集中式系统中有冲突、线程问题用sychronized锁机制，在分布式中通常会想到第三方去解决 如zookeeper。需求：很多客户端都去请求共享资源(网络接口)，可能会有冲突情况，怎么解决解决思路：客户端到zk中去注册锁信息(uuid或其它序号)，每次客户端请求共享资源时都会通过zk去请求，zk会根据各个客户端的锁信息如序号取最小值(或最大值)，获取资源成功后删除锁信息，这是触发监听事件通知其他客户端在获取资源，删除的客户端重新生成序号在排队等待。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JVM浅谈]]></title>
      <url>%2F2016%2F12%2F19%2FJVM%E6%B5%85%E8%B0%88%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[常见易混淆命令]]></title>
      <url>%2F2016%2F12%2F19%2F%E5%B8%B8%E8%A7%81%E6%98%93%E6%B7%B7%E6%B7%86%E5%91%BD%E4%BB%A4(%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD......)%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[SSH协议]]></title>
      <url>%2F2016%2F12%2F17%2FSSH%E5%8D%8F%E8%AE%AE%2F</url>
      <content type="text"><![CDATA[浅述简单点说，ssh是网络安全外壳协议。用于计算机之间的加密协议，即使信息被截获密码也不会泄露（为什么自己去百度，这里不做重点） 在大数据领域中ssh用于安全登录，被称为免密码登录。 通常用法ssh-keygen [-t][-p] rsa/dsa(默认rsa算法可以去掉参数t)此命令会在.ssh文件夹下生产id_rsa id_rsa.pub或id_dsa id_dsa.pub,即私钥 公钥 实现免密码登录1.通过scp 公钥 用户名@主机名:/.ssh 将公钥拷贝到另一个主机中2.在另一台主机中 通过cat 公钥 &gt; /.ssh/authorized_keys 进行授权操作。上面2步可以简化为一步ssh-copy-id 实现拷贝公钥的同时进行了授权操作，建议优先使用。 聊聊ssh验证机制ssh有2种身份验证机制1.用户名+密码（用xshell或secureCRT连接使用ssh支持这种机制）2.密钥验证目标主机会跟根据授权文件中是否有请求方的公钥信息，如果有则根据对方公钥生成加密信息，再将加密信息发给请求连接方，请求连接方根据自己的私钥去解密生成解密文件在发送给目标主机，目标主机判断正确则允许连接。 常见的连接错误ssh_exchange_identification: Connection closed by remote host方法一.把SSH连接数改大方法二.检查/etc/hosts.deny和/etc/hosts.allow里面是否屏蔽了某些帐户]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[企业级服务器]]></title>
      <url>%2F2016%2F12%2F16%2F%E4%BC%81%E4%B8%9A%E7%BA%A7%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
      <content type="text"><![CDATA[LZ接触过hp系列的服务器，这里只对hp-DL580、hp-DL388、hp-DL380、hp-P4500等型号浅谈. 名词解释企业级：属于高档服务器,具有高内存带宽，大容量热插拔硬盘和热插拔电源，具有超强的数据处理能力机架式：机架式服务器的外形看来不像计算机，而像交换机.结构(几U)：U是一种表示服务器外部尺寸的单位,是unit的缩略语,1U=4.445cm 注意：CPU数量绝对不是CPU核心 1个CPU叫单处理器，2个CPU叫双处理器。1个CPU可以是双核货单核。 HP-DL380（此款已停产）此款服务器，售价在2-3W之间，内存标配为12G,可扩展到192G ,硬盘标配为584GB hp-DL388此款服务器，售价在2W左右，内存标配为32G,可扩展到768G ,硬盘标配为584GB HP-DL580此款服务器，售价在5.5W左右，内存标配为32G 可以最大扩展到2T内存以上，硬盘标配为4T。 HP-P4500此款系列服务器绝对高配了，售价在10W-20W之间，最大存储可达到24T 附带真实工作环境中的机房拓扑图]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[谈谈程序员的几个阶段]]></title>
      <url>%2F2016%2F12%2F15%2F%E8%B0%88%E8%B0%88%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%87%A0%E4%B8%AA%E9%98%B6%E6%AE%B5%2F</url>
      <content type="text"><![CDATA[关于程序员的几个阶段每个程序员、或者说每个工作者都应该有自己的职业规划，如果看到这里的朋友没有自己的职业规划，希望你可以思考一下自己的将来。LZ常常思考自己的未来,鉴于文笔拙劣，阅历浅薄。以下内容摘录于互联网，LZ拿出来，自勉、共勉之。 第一阶段：三年我认为三年对于程序员来说是第一个门槛，这个阶段将会淘汰掉一批不适合写代码的人。这一阶段，我们走出校园，迈入社会，成为一名程序员，正式从书本上的内容迈向真正的企业级开发。我们知道如何团队协作、如何使用项目管理工具、项目版本如何控制、我们写的代码如何测试如何在线上运行等等，积累了一定的开发经验，也对代码有了一定深入的认识，是一个比较纯粹的Coder的阶段 第二阶段：五年五年又是区分程序员的第二个门槛。有些人在三年里，除了完成工作，在空余时间基本不会研究别的东西，这些人永远就是个Coder，年纪大一些势必被更年轻的人给顶替；有些人在三年里，除了写代码之外，还热衷于研究各种技术实现细节、看了N多好书、写一些博客、在Github上分享技术，这些人在五年后必然具备在技术上独当一面的能力并且清楚自己未来的发展方向，从一个Coder逐步走向系统分析师或是架构师，成为项目组中不可或缺的人物 第三阶段：十年十年又是另一个门槛了，转行或是继续做一名程序员就在这个节点上。如果在前几年就抱定不转行的思路并且为之努力的话，那么在十年的这个节点上，有些人必然成长为一名对行业有着深入认识、对技术有着深入认识、能从零开始对一个产品进行分析的程序员，这样的人在公司基本担任的都是CTO、技术专家、首席架构师等最关键的职位，这对于自己绝对是一件荣耀的事，当然老板在经济上也绝不会亏待你 工作浅谈我认为，随着你工作年限的增长、对生活对生命认识的深入，应当不断思考三个问题：1、我到底适不适合当一名程序员？2、我到底应不应该一辈子以程序员为职业？3、我对编程到底持有的是一种什么样的态度，是够用就好呢还是不断研究？最终，明确自己的职业规划，对自己的规划负责并为之努力。 关于项目经验LZ在网上经常看到一些别的朋友有提出项目经验的问题，依照LZ面试的感觉来说，面试主要看几点：项目经验+基本技术+个人潜力（也就是值不值得培养）。 关于项目经验，我认为并发编程网的创始人方腾飞老师讲的一段话非常好：介绍产品时面试官会考察应聘者的沟通能力和思考能力，我们大部分情况都是做产品的一个功能或一个模块，但是即使是这样，自己有没有把整个系统架构或产品搞清楚，并能介绍清楚，为什么做这个系统？这个系统的价值是什么？这个系统有哪些功能？优缺点有哪些？如果让你重新设计这个系统你会如何设计？ 我觉得这就已经足以概括了。也许你仅仅工作一年，也许你做的是项目中微不足道的模块，当然这些一定是你的劣势且无法改变，但是如何弥补这个劣势，从方老师的话中我总结几点：1、明确你的项目到底是做什么的，有哪些功能2、明确你的项目的整体架构，在面试的时候能够清楚地画给面试官看并且清楚地指出从哪里调用到哪里、使用什么方式调用3、明确你的模块在整个项目中所处的位置及作用4、明确你的模块用到了哪些技术，更好一些的可以再了解一下整个项目用到了哪些技术 在你无法改变自己的工作年限、自己的不那么有说服力的项目经验的情况下（这一定是扣分项），可以通过这种方式来一定程度上地弥补并且增进面试官对你的好感度。 关于奔三程序员之后转行的反驳。讲到了奔三程序员的困惑，大致说的是三十岁之后程序员要转行之类的云云.]]></content>
    </entry>

    
  
  
</search>
